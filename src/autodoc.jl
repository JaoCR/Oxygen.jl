module AutoDoc
using HTTP
using JSON3
using Dates
using DataStructures
using Reexport
using RelocatableFolders
using StructTypes: StructTypes as stt

using ..Util: html, recursive_merge
using ..Constants
using ..AppContext: ServerContext, Documenation
using ..Types: TaggedRoute, TaskDefinition, CronDefinition, Nullable, Param, isrequired
using ..Extractors: isextractor, extracttype, isreqparam
using ..Reflection: splitdef

export registerschema, swaggerhtml, redochtml, mergeschema

const OrderedDictSA = OrderedDict{String,Any}
const DictSA = Dict{String,Any}

"Merge the schema of a specific route."
function mergeschema(schema::Dict, route::String, customschema::Dict)
    schema["paths"][route] = recursive_merge(get(schema["paths"], route, DictSA()), customschema)
end

"Merge the top-level autogenerated schema with a custom schema."
function mergeschema(schema::Dict, customschema::Dict)
    updated_schema = recursive_merge(schema, customschema)
    merge!(schema, updated_schema)
end

"OpenAPI equivalent name for a given simple type."
type_id(T::Type)::Nullable{String} = type_id(stt.StructType(T)) # general case
type_id(::Type{<:Integer})::String = "integer" # edge case of integers, different id
type_id(::stt.DictType)::String = "object"
type_id(::stt.ArrayType)::String = "array"
type_id(::stt.StringType)::String = "string"
type_id(::stt.NumberType)::String = "number"
type_id(::stt.BoolType)::String = "bool"
type_id(_)::Nothing = nothing

"OpenAPI type schema definition for a given simple type."
function type_schema(T::Type)::Nullable{Dict}
    type_string = type_id(T)
    type_string === nothing && return nothing
    type_def = DictSA("type" => type_string)
    add_format!(T, type_def)
    return type_def
end

"OpenAPI format name for a given parameter (eg. DateTime(2022,1,1) => \"date-time\")"
format_id(T::Type)::Nullable{String} = format_id(stt.StructType(T))
format_id(::Type{Float32})::String = "float"
format_id(::Type{<:Integer})::String = "int64"
format_id(::Type{Int32})::String = "int32"
format_id(::Type{Date})::String = "date"
format_id(::Type{DateTime})::String = "date-time"
format_id(::stt.NumberType)::String = "double"
format_id(_)::Nothing = nothing

"Adds format key to dict if a format string exists for the given type."
function add_format!(T::Type, d::Dict)
    format = format_id(T)
    if format !== nothing
        d["format"] = format
    end
end

"Returns openapi reference for a given type."
function get_schema!(T::Type, schemas::Dict)::Dict
    types = T |> Base.uniontypes |> unique |> filter(∉((Union{}, Any, Nothing, Missing)))
    return if length(types) == 0
        DictSA()
    elseif length(types) == 1
        get_schema!(stt.StructType(types[1]), types[1], schemas)
    else
        Dict("oneOf" => [get_schema!(sst.StructType(t), t, schemas) for t ∈ types])
    end
end

function get_schema!(::stt.InterfaceType, T::Type, _)::Dict
    return type_schema(T)
end

function get_schema!(::stt.CustomStruct, T::Type, schemas::Dict)::Dict
    return get_schema!(stt.lowertype(T), schemas)
end

function get_schema!(::stt.DataType, T::Type, schemas::Dict)::Dict
    register_object_schema!(T, schemas)
    return DictSA("\$ref" => "#/components/schemas/$(T|>nameof|>string)")
end

function get_schema!(::stt.ArrayType, T::Type, schemas::Dict)::Dict
    # [NOTE] ArrayType is subtype of Interface Type, and has precedence.
    # So this function handles the edge case for specifying array items.

    type_refs = Base.uniontypes(eltype(T)) |>
                unique |>
                filter(!=(Any)) .|>
                (T -> get_schema!(T, schemas))

    schema = type_schema(T)

    if length(type_refs) == 1
        schema["items"] = type_refs[1]
    elseif length(type_refs) > 1
        schema["items"] = DictSA("oneOf" => type_refs)
    end

    return schema

end

"Adds response content option to the content dict, updating schemas if needed."
function add_response_content!(T::Type, schemas::Dict, content::Dict)
    return add_response_content!(stt.StructType(T), T, schemas, content)
end

function add_response_content!(
    ::Union{stt.CustomStruct,stt.DataType,stt.ArrayType},
    T::Type,
    schemas::Dict,
    content::Dict,
)
    if !haskey(content, "application/json")
        content["application/json"] = DictSA("oneOf" => Any[])
    end
    schema = get_schema!(T, schemas)
    push!(content["application/json"]["oneOf"], schema)
end

function add_response_content!(_, T::Type, schemas::Dict, content::Dict)
    if !haskey(content, "text/plain")
        content["text/plain"] = DictSA("oneOf" => Any[])
    end
    push!(content["text/plain"]["oneOf"], get_schema!(T, schemas))
end




function register_object_schema!(T::Type, schemas::Dict)

    typename = T |> nameof |> string

    # handle already registered types
    haskey(schemas, typename) && return

    # intilaize this entry
    properties = DictSA()
    required = []
    type_schema = DictSA("type" => "object", "properties" => properties)

    # doing it here to avoid re-registering during recursion
    schemas[typename] = type_schema

    # parse out the fields of the type
    info = splitdef(T)

    # Make sure we have a unique set of names (in case of duplicate field names when parsing types)
    # The same field names can show up as regular parameters and keyword parameters when the type is used with @kwdef
    sig_names = OrderedSet{Symbol}(p.name for p in info.sig)

    # loop over all fields
    for name ∈ sig_names
        p = info.sig_map[name]
        field_name = string(p.name)
        FT = p.type
        field_schema = get_schema!(FT, schemas)
        if isrequired(p)
            push!(required, field_name)
        end
        if p.hasdefault
            field_schema["default"] = JSON3.write(p.default)
        end
        properties[field_name] = field_schema
    end

    # for object schemas, the required fields are specified in a separated list
    if !isempty(required)
        type_schema["required"] = required
    end

end


function createparam(p::Param{T}, paramtype::String)::Dict where {T}

    schema = type_schema(p.type)

    # Add default value if it exists
    if p.hasdefault
        schema["default"] = string(p.default)
    end

    # path params are always required
    param_required = paramtype == "path" ? true : isrequired(p)

    param = DictSA(
        "in" => paramtype, # path, query, header (where the parameter is located)
        "name" => String(p.name),
        "required" => param_required,
        "schema" => schema
    )

    return param
end


"""
This function helps format the individual parameters for each route in the openapi schema
"""
function formatparam!(params::Vector{Any}, p::Param{T}, paramtype::String) where T
    # Will need to flatten request extrators & append all properties to the schema
    if isextractor(p) && isreqparam(p)
        type = extracttype(p.type)
        info = splitdef(type)
        sig_names = OrderedSet{Symbol}(p.name for p in info.sig)
        for name in sig_names
            push!(params, createparam(info.sig_map[name], paramtype))
        end
    else
        push!(params, createparam(p, paramtype))
    end
end

"""
This function helps format the content object for each route in the openapi schema.

If similar body extractors are used, all schema's are included using an "allOf" relation.
The only exception to this is the text/plain case, which excepts the Body extractor.
If there are more than one Body extractor, the type defaults to string - since this is
the only way to represent multiple formats at the same time.

Returns the formatted content and the required object schemas.
"""
function formatcontent(bodyparams::Vector)::Tuple{OrderedDict,Dict}

    body_refs = DictSA()
    body_types = DictSA()
    object_schemas = DictSA()

    for p in bodyparams

        inner_type = p.type |> extracttype
        extractor_name = p.type |> nameof |> string

        body_types[extractor_name] = type_id(inner_type)

        component_ref = get_schema!(inner_type, object_schemas)

        if !haskey(body_refs, extractor_name)
            body_refs[extractor_name] = []
        end

        push!(body_refs[extractor_name], component_ref)

    end

    jsonschema = collectschemarefs(body_refs, ["Json", "JsonFragment"])

    # The schema type for text/plain can vary unlike the other types
    textschema = collectschemarefs(body_refs, ["Body"])
    # If there are multiple Body extractors, default to string type
    textschema_type = if haskey(textschema, "allOf")
        "string"
    else
        get(body_types, "Body", "string")
    end
    textschema = merge(textschema, DictSA("type" => textschema_type))

    formschema = collectschemarefs(body_refs, ["Form"])
    formschema = merge(formschema, DictSA("type" => "object"))

    content = DictSA(
        "application/json" => DictSA(
            "schema" => jsonschema
        ),
        "text/plain" => DictSA(
            "schema" => textschema
        ),
        "application/x-www-form-urlencoded" => DictSA(
            "schema" => formschema
        ),
        "application/xml" => DictSA(
            "schema" => DictSA(
                "type" => "object"
            )
        ),
        "multipart/form-data" => DictSA(
            "schema" => DictSA(
                "type" => "object",
                "properties" => DictSA(
                    "file" => DictSA(
                        "type" => "string",
                        "format" => "binary"
                    )
                ),
                "required" => ["file"]
            )
        )
    )

    ##### Add Schemas to this route, with the preferred content type first #####
    ordered_content = OrderedDictSA()

    if !isempty(jsonschema)
        ordered_content["application/json"] = DictSA("schema" => jsonschema)
    end

    if !isempty(textschema)
        ordered_content["text/plain"] = DictSA("schema" => textschema)
    end

    if !isempty(formschema)
        ordered_content["application/x-www-form-urlencoded"] = DictSA("schema" => formschema)
    end

    # Add all other content types (won't default to these, but they are available)
    for (key, value) in content
        if !haskey(ordered_content, key)
            ordered_content[key] = value
        end
    end

    return ordered_content, object_schemas
end


"""
Used to generate & register schema related for a specific endpoint
"""
function registerschema(
    docs::Documenation,
    path::String,
    httpmethod::String,
    parameters::Vector,
    queryparams::Vector,
    headers::Vector,
    bodyparams::Vector,
    returntypes::Vector,
)
    ##### Append the parameter schema for the route #####
    params = []

    for (param_list, location) in [(parameters, "path"), (queryparams, "query"), (headers, "header")]
        for p in param_list
            formatparam!(params, p, location)
        end
    end

    ##### Set the schema for the body parameters #####
    content, schemas = formatcontent(bodyparams)

    components = DictSA("components" => DictSA("schemas" => schemas))
    if !isempty(schemas)
        mergeschema(docs.schema, components)
    end

    # lookup if this route has any registered tags
    if haskey(docs.taggedroutes, path) && httpmethod in docs.taggedroutes[path].httpmethods
        tags = docs.taggedroutes[path].tags
    else
        tags = []
    end

    content = DictSA()
    returntypes = Iterators.flatmap(Base.uniontypes, returntypes) |>
                  unique |> filter(∉((Union{}, Any, Nothing, Missing)))
    for RT ∈ returntypes
        add_response_content!(RT, schemas, content)
    end

    # Build the route schema
    route = DictSA(
        "$(lowercase(httpmethod))" => DictSA(
            "tags" => tags,
            "parameters" => params,
            "responses" => DictSA(
                "200" => DictSA(
                    "description" => "200 response",
                    "content" => content,
                ),
                "500" => DictSA("description" => "500 Server encountered a problem")
            )
        )
    )

    # Add a request body to the route if it's a POST, PUT, or PATCH request
    if httpmethod in ["POST", "PUT", "PATCH"] || !isempty(bodyparams)
        route[lowercase(httpmethod)]["requestBody"] = DictSA(
            # if any body param is required, mark the entire body as required
            "required" => any(p -> isrequired(p), bodyparams),
            "content" => content
        )
    end

    # remove any special regex patterns from the path before adding this path to the schema
    cleanedpath = replace(path, r"(?=:)(.*?)(?=}/)" => "")
    mergeschema(docs.schema, cleanedpath, route)

end

function collectschemarefs(data::Dict, keys::Vector{String}; schematype="allOf")
    refs = []
    for key in keys
        if haskey(data, key)
            append!(refs, data[key])
        end
    end
    return if length(refs) == 0
        DictSA()
    elseif length(refs) == 1
        refs[1]
    else
        DictSA("$schematype" => refs)
    end
end


"""
Read in a static file from the /data folder
"""
function readstaticfile(filepath::String)::String
    path = joinpath(DATA_PATH, filepath)
    return read(path, String)
end


function redochtml(schemapath::String, docspath::String) :: HTTP.Response
    redocjs = readstaticfile("$REDOC_VERSION/redoc.standalone.js")

    html("""
    <!DOCTYPE html>
    <html lang="en">

        <head>
            <title>Docs</title>
            <meta charset="utf-8"/>
            <meta name="description" content="Docs" />
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <link rel="icon" type="image/x-icon" href="$docspath/metrics/favicon.ico">
        </head>
        
        <body>
            <redoc spec-url="$schemapath"></redoc>
            <script>$redocjs</script>
        </body>

    </html>
    """)
end


"""
Return HTML page to render the autogenerated docs
"""
function swaggerhtml(schemapath::String, docspath::String) :: HTTP.Response

    # load static content files
    swaggerjs = readstaticfile("$SWAGGER_VERSION/swagger-ui-bundle.js")
    swaggerstyles = readstaticfile("$SWAGGER_VERSION/swagger-ui.css")

    html("""
        <!DOCTYPE html>
        <html lang="en">
        
        <head>
            <title>Docs</title>
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <meta name="description" content="Docs" />
            <style>$swaggerstyles</style>
            <link rel="icon" type="image/x-icon" href="$docspath/metrics/favicon.ico">
        </head>
        
        <body>
            <div id="swagger-ui"></div>
            <script>$swaggerjs</script>
            <script>
                window.onload = () => {
                    window.ui = SwaggerUIBundle({
                        url: "$schemapath",
                        dom_id: '#swagger-ui',
                    });
                };
            </script>
        </body>
        
        </html>
    """)
end

end
